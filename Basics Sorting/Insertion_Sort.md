# Insertion Sort - 插入排序

核心：对于未排序序列中的每一个元素，在已排序序列中从后向前（对于单向链表则只能从前向后）遍历，找到相应的位置并插入。实现上通常使用in-place排序（需要$O(1)$的额外空间）

1. 从第一个元素开始，该元素可认为已排序，剩下的元素序列则为未排序元素序列。
2. 从未排序序列中取出元素Ａ，对已排序数组从后向前扫描
3. 元素Ａ通过与已排序元素逐个比较，找到未排序元素Ａ在已排序元素序列中的位置，并插入，Ａ就加入到了已排序元素序列
4. 重复上述的２、３操作，直到所有元素都已排序

性质：

- 交换(赋值)操作和数组中倒置的数量相同
- 比较次数>=倒置数量，比较次数<=倒置数量加上数组的大小减１
- 每次交换(赋值)都减少了一对倒置，当倒置数量为０是即完成排序。
- 最坏情况下需要~$N^2/2$次比较和~$N^2/2$次交换，最好情况下需要$N-1$次比较和０次交换
- 平均情况下需要~$N^2/4$次比较和~$N^2/4$次交换

```python
def insertionSort(alist):
	for i, item_i in enumerate(alist):
		while i > 0 and alist[i-1] > item_i:
            alist[i] = alist[i-1]
            i -= 1
        alist[i] = item_i
    
    return alist
```

> 复杂度分析
>
> 时间上，嵌套循环，最好为复杂度为$O(n)$，平均为$O(n^2)$
>
> 空间上，额外的空间为$O(1)$

# 希尔排序

希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

通过一个例子来理解希尔排序

例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为５开始进行排序，我们可以通过将这列表放在有５列的表中来更好的描述算法，这样他们就应该看起来是这样：

```
13 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10
```

然后我们对每列进行排序

```
10 14 73 25 23
13 27 94 33 39
25 59 94 65 82
45
```

将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]. 此时10已经移至正确位置了，然后再以３为步长进行排序：

```
10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45
```

排序之后变为：

```
10 14 13
25 23 33
27 25 59
39 65 73
45 94 82
94
```

最后以１步长进行排序（此时就是简单的插入排序了）

## 步长序列

步长的选择是希尔排序的重要部分。只要最终步长为１任何序列都可以工作。算法最开始以一定的步长排序。然后继续以一定步长进行排序，最终算法以步长为１进行排序。当步长为１时，算法变为普通插入排序，这就保证了数据一定会被排序。

**希尔排序**最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。

### python

```python
def shell_sort(alist):
    n = len(alist)
    # 初始步长
    gap = n // 2
    while gap > 0:
        # 每个步长进行插入排序
        for i in range(gap, n):
            item = alist[i]
            while i>=gap and alist[i-gap]>item:
                alist[i] = alist[i-gap]
                i -= gap
            alist[i] = item
        # 得到新的步长
        gap = gap // 2
    return alist
```

### 复杂度分析

| 步长序列     | 最坏情况下复杂度     |
| -------- | ------------ |
| $n/2^i$  | $O(n^2)$     |
| $2^k-1$  | $O(n^{3/2})$ |
| $2^i3^j$ | $O(nlog^2n)$ |

**最坏的时间复杂度**

根据步长序列的不同而不同。已知最好的：  $O(nlog^2n)$

**最优时间复杂度**

$O(n)$

**平均时间复杂度**

根据步长序列的不同而不同