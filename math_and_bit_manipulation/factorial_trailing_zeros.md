# Question

## 题目描述

给定一个整数 *n*，返回 *n*! 结果尾数中零的数量。

**示例 1:**

```
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```

**示例 2:**

```
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```

## 题解

具体的题解分析见代码注释

### python 

```python
class Solution:
    def trailingZeroes(self, n):
        """
        :type n: int
        :rtype: int
        """
        # 首先这道题，自己没想出来，又是看别人的。。。
        # 想来想去，能够使尾数增加０的最小单位相乘不就是2 * 5
        # 因此就要找整个阶乘中 2*5的对数（包括一些阶乘数分解出来的2和5)
        # 由于是阶乘，因此就可以稍微想想，最终分解后，２的个数一定不会少于５
        # 因此，这道题就转化为了求n的所有阶乘数中包含质因数５的总个数
        # 那么怎么求呢？
        
        
        # 处理异常情况
        if n < 0:
            return -1
        if n == 0:
            return 0
        
        # 迭代版本
#         count = 0
#         while n:
#             n //= 5
#             count += n
        
#         return count
        
        # 递归版本
        return n//5 + self.trailingZeroes(n//5)
```

### 复杂度分析

> 时间上，无论递归还是迭代，复杂度为$O(log_5n)$
>
> 空间上，迭代使用的额外空间为$O(1)$，递归由于只有函数参数，占用的是栈空间，因此可以认为没有额外的空间复杂度。