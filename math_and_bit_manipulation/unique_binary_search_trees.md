# Question

- leecode [不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

## 题目描述

给定一个整数 *n*，求以 1 ... *n* 为节点组成的二叉搜索树有多少种？

**示例:**

```
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

## 题解

这道题又是看别人才会的。。。

首先咱要明白什么是二叉搜索树，【以i为根节点的树，其左子树由[1，i-1]组成，其右子树由[i+1，ｎ]组成。

容易想到这道题的动态规划的状态为count[n]，count[n]表示到正整数n为止的二叉搜索树个数。容易得到count[1]=1，根节点为1，count[2]=2，根节点为1或２。那么count[3]的根节点自然可为1,2,3。如果以１为根节点，那么根据BST的定义，２和３只可能位于根节点１的右边；如果以２为根节点，则１位于左子树，３位于右子树；如果以３为根节点，则１和２必位于３的左子树。

抽象一下。如果以ｉ为根节点，由基本的排列组合知识可知，其BST个数为左子树BST个数乘上右子树BST个数。故对于ｉ来说，其左子树由[1, i-1]组成，BST个数为count[i-1]。右子树由【ｉ+1, n]组成，其BST个数没有左子树直观，但也有迹可循。对于两组有序数列[1,2,3]和[4,5,6]来说，**这两个有序数列的BST个数是相同的，因为BST个数只与有序序列大小有关，与具体的值无关。**所以右子树BST个数为count[n-i]。于是就得到了如下的递推关系：
$count[i] = \sum_{j=1}^{j=i}(count[j-1]*count[i-j])$

### python 

```python
class Solution:
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        
        # 首先你要明白啥是二叉搜索树呀
        # 具体分析过程见笔记
        
        # 处理异常情况
        if n < 1:
            return 0
        
        count = [0] * (n+1)
        
        count[0] = 1
        
        for i in range(1, n+1):
            for j in range(1, i+1):
                count[i] += count[j-1] * count[i-j]
                
        
        return count[n]
        
```

### 复杂度分析

>  时间上，双重for循环的计算次数大约为$n^2/2$，因此时间复杂度为$O(n^2)$
>
> 空间上，使用额外的数组空间为$O(n)$



